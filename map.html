<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Navigation Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Leaflet Routing Machine CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <!-- Leaflet GeometryUtil -->
  <script src="https://unpkg.com/leaflet-geometryutil@0.10.0/dist/leaflet.geometryutil.js"></script>
  <style>
    html, body { height:100%; margin:0; }
    #map { height:60vh; width:100%; }
    #direction-panel, #hotspot-list { overflow-y:auto; }
    .suggestions {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 0.25rem;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
    }
    .suggestion-item {
      padding: 0.5rem;
      cursor: pointer;
    }
    .suggestion-item:hover {
      background-color: #f3f4f6;
    }
  </style>
</head>
<body class="bg-gray-100 font-sans">

  <!-- Nav Bar -->
  <nav class="bg-gray-800 p-4">
    <div class="container mx-auto flex items-center justify-between">
      <h1 class="text-white text-xl font-bold">Navigation Pro</h1>
      <!-- Previous Location Button -->
      <button id="prev-btn" class="p-2 bg-yellow-500 text-white rounded shadow hover:bg-yellow-600" onclick="routeToPrevious()">Previous Location</button>
    </div>
  </nav>

  <div class="container mx-auto px-4 py-4 relative">

    <!-- Controls -->
    <div id="controls" class="mb-4">
      <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">

        <!-- From -->
        <div class="relative">
          <input type="text" id="from"
                 class="w-full p-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                 placeholder="Starting location">
          <button class="w-full mt-2 p-2 border rounded hover:bg-gray-200" onclick="startSpeechRecognition('from')">üé§</button>
        </div>

        <!-- To with autocomplete -->
        <div class="relative">
          <input type="text" id="to"
                 class="w-full p-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                 placeholder="Destination" autocomplete="off">
          <div id="to-suggestions" class="suggestions hidden"></div>
          <button class="w-full mt-2 p-2 border rounded hover:bg-gray-200" onclick="startSpeechRecognition('to')">üé§</button>
        </div>

        <!-- Get Route -->
        <div>
          <button class="w-full p-2 bg-blue-600 text-white rounded shadow hover:bg-blue-700" onclick="calculateRoute()">Get Route</button>
        </div>

        <!-- Hotspots -->
        <div>
          <select id="hotspot-type" class="w-full p-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="hospital">Hospitals</option>
            <option value="restaurant">Restaurants</option>
            <option value="school">Schools</option>
            <option value="bank">Banks</option>
          </select>
          <button class="w-full mt-2 p-2 bg-gray-600 text-white rounded shadow hover:bg-gray-700" onclick="findNearbyHotspots()">Find Nearby</button>
        </div>

      </div>
    </div>

    <!-- Home Button -->
    <button class="absolute top-5 left-5 p-3 bg-white rounded-full shadow hover:bg-gray-200" onclick="locateMe()">üè†</button>

    <!-- Map -->
    <div id="map" class="mb-4 rounded shadow"></div>

    <!-- Directions -->
    <div id="direction-panel" class="bg-white p-4 rounded shadow mb-4 h-32 border border-gray-200">
      Direction instructions will appear here...
    </div>

    <!-- Hotspot List -->
    <div id="hotspot-list" class="bg-white p-4 rounded shadow h-40 border border-gray-200">
      Nearby hotspots will appear here...
    </div>

  </div>

  <!-- Leaflet & Routing -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
  <script>
    // Globals
    let map, marker, routeControl, watchId;
    let currentLat, currentLng;
    let instructions = [];
    let hotspotMarkers = [];
    let announcementInterval;
    let prevLat = null, prevLng = null;
    let routePolyline, totalDistance;
    let currentManeuverIndex = 0;
    let lastAnnouncedDistance = null;
    let previousManeuverIndex = -1;

    const osrmRouter = L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1' });

    document.addEventListener('DOMContentLoaded', locateMe);

    function locateMe() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported‚Äîusing default view.");
        initMap(20, 77);
        return;
      }
      navigator.geolocation.getCurrentPosition(
        pos => { currentLat = pos.coords.latitude; currentLng = pos.coords.longitude; initMap(currentLat, currentLng); },
        err => { console.warn(err.message); alert("Could not get location: " + err.message); initMap(20, 77); },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    function initMap(lat, lng) {
      map = L.map('map').setView([lat, lng], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap contributors' }).addTo(map);
      marker = L.marker([lat, lng], { draggable: true }).addTo(map).bindPopup("You are here").openPopup();
      marker.on('dragend', () => { const p = marker.getLatLng(); currentLat = p.lat; currentLng = p.lng; reverseGeocode(p.lat, p.lng); });
      reverseGeocode(lat, lng);
      startWatchingPosition();
      document.getElementById('to').addEventListener('input', handleAutocomplete);
    }

    function reverseGeocode(lat, lon) {
      fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`)
        .then(resp => resp.json())
        .then(data => { if (data.display_name) document.getElementById('from').value = data.display_name; })
        .catch(console.error);
    }

    function startSpeechRecognition(inputId) {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return alert("Speech recognition not supported.");
      const r = new SR(); r.lang = 'en-US'; r.start();
      r.onresult = e => document.getElementById(inputId).value = e.results[0][0].transcript;
    }

    function handleAutocomplete() {
      clearTimeout(this.debounce);
      const val = document.getElementById('to').value.trim();
      const box = document.getElementById('to-suggestions');
      if (!val) { box.innerHTML = ''; box.classList.add('hidden'); return; }
      this.debounce = setTimeout(async () => {
        try {
          const res = await fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=5&q=${encodeURIComponent(val)}`);
          const places = await res.json();
          box.innerHTML = '';
          places.forEach(p => {
            const div = document.createElement('div'); div.className = 'suggestion-item'; div.innerText = p.display_name;
            div.onclick = () => { document.getElementById('to').value = p.display_name; box.innerHTML = ''; box.classList.add('hidden'); };
            box.appendChild(div);
          });
          box.classList.toggle('hidden', places.length === 0);
        } catch (e) { console.error(e); }
      }, 300);
    }

    function calculateRoute() {
      const dest = document.getElementById('to').value.trim();
      if (!currentLat || !currentLng) return alert("Location not ready.");
      if (!dest) return alert("Enter a destination.");
      if (routeControl) map.removeControl(routeControl);
      fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(dest)}`)
        .then(r => r.json())
        .then(data => {
          if (!data.length) return alert("Destination not found.");
          const [lat, lon] = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
          prevLat = lat; prevLng = lon;
          routeControl = L.Routing.control({ waypoints: [L.latLng(currentLat, currentLng), L.latLng(lat, lon)], router: osrmRouter, routeWhileDragging: true, show: false }).addTo(map);
          routeControl.on('routesfound', onRouteFound);
        }).catch(console.error);
    }

    function routeToPrevious() {
      if (prevLat === null || prevLng === null) return alert("No previous location found.");
      if (routeControl) map.removeControl(routeControl);
      calculateRouteTo(prevLat, prevLng);
    }

    function onRouteFound(e) {
      if (announcementInterval) clearInterval(announcementInterval);
      const route = e.routes[0];
      const sum = route.summary;
      totalDistance = sum.totalDistance;
      routePolyline = L.polyline(route.coordinates);

      instructions = route.instructions.map(inst => {
        let txt = inst.text;
        const dist = Math.round(inst.distance);
        txt = txt.replace(/\b(north|south|east|west)\b/gi, '').trim();
        txt = txt.replace(/^Head\s*/i, 'Go straight ');
        return { text: txt, distance: dist, index: inst.index, cumulativeDistance: 0, announced50m: false, announced10m: false };
      });

      // Compute cumulative distances
      let cumulative = 0;
      const cumulativeDistances = [0];
      for (let i = 1; i < route.coordinates.length; i++) {
        const p1 = route.coordinates[i - 1];
        const p2 = route.coordinates[i];
        cumulative += getDistance(p1.lat, p1.lng, p2.lat, p2.lng);
        cumulativeDistances.push(cumulative);
      }
      instructions.forEach(ins => {
        ins.cumulativeDistance = cumulativeDistances[ins.index];
      });

      const panel = document.getElementById('direction-panel');
      panel.innerHTML = `<div class="font-bold mb-1">Route: ${Math.round(sum.totalDistance)} m, ETA: ${Math.round(sum.totalTime / 60)} min</div>`;
      instructions.forEach((ins, i) => {
        const d = document.createElement('div');
        d.innerText = `${i + 1}. ${ins.text} (${ins.distance} m)`;
        panel.appendChild(d);
      });

      currentManeuverIndex = 0;
      lastAnnouncedDistance = null;
      previousManeuverIndex = -1;
      if (instructions.length > 0) {
        speakText(`${instructions[0].text} for ${Math.round(instructions[0].distance)} meters`);
      }

      announcementInterval = setInterval(() => {
        const userLatLng = L.latLng(currentLat, currentLng);
        const t = L.GeometryUtil.locateOnLine(map, routePolyline, userLatLng);
        const userDistance = t * totalDistance;

        // Update currentManeuverIndex
        while (currentManeuverIndex < instructions.length - 1 && userDistance >= instructions[currentManeuverIndex + 1].cumulativeDistance) {
          currentManeuverIndex += 1;
        }

        if (currentManeuverIndex !== previousManeuverIndex) {
          lastAnnouncedDistance = null;
          previousManeuverIndex = currentManeuverIndex;
        }

        if (currentManeuverIndex < instructions.length - 1) {
          const nextIns = instructions[currentManeuverIndex + 1];
          const remainingDistance = nextIns.cumulativeDistance - userDistance;
          if (remainingDistance <= 50 && !nextIns.announced50m) {
            speakText(`In ${Math.round(remainingDistance)} meters, ${nextIns.text}`);
            nextIns.announced50m = true;
          } else if (remainingDistance <= 10 && !nextIns.announced10m) {
            speakText(`${nextIns.text} now`);
            nextIns.announced10m = true;
          } else if (remainingDistance > 50) {
            const roundedDistance = Math.round(remainingDistance / 10) * 10;
            if (roundedDistance !== lastAnnouncedDistance) {
              speakText(`Continue straight for ${roundedDistance} meters`);
              lastAnnouncedDistance = roundedDistance;
            }
          }
        } else if (currentManeuverIndex === instructions.length - 1 && userDistance >= instructions[currentManeuverIndex].cumulativeDistance - 10) {
          speakText("You have arrived at your destination");
          clearInterval(announcementInterval);
        }
      }, 5000);
    }

    function calculateRouteTo(lat, lon) {
      if (routeControl) map.removeControl(routeControl);
      if (lat !== prevLat || lon !== prevLng) { prevLat = lat; prevLng = lon; }
      routeControl = L.Routing.control({ waypoints: [L.latLng(currentLat, currentLng), L.latLng(lat, lon)], router: osrmRouter, routeWhileDragging: true, show: false }).addTo(map);
      routeControl.on('routesfound', onRouteFound);
    }

    function startWatchingPosition() {
      if (watchId) navigator.geolocation.clearWatch(watchId);
      watchId = navigator.geolocation.watchPosition(
        pos => { currentLat = pos.coords.latitude; currentLng = pos.coords.longitude; marker.setLatLng([currentLat, currentLng]); },
        err => { console.error(err); alert("Error getting location: " + err.message); },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    }

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000, r = Math.PI / 180;
      const dLat = (lat2 - lat1) * r, dLon = (lon2 - lon1) * r;
      const a = Math.sin(dLat / 2) ** 2 + Math.cos(lat1 * r) * Math.cos(lat2 * r) * Math.sin(dLon / 2) ** 2;
      return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function speakText(txt) {
      if (!('speechSynthesis' in window)) return;
      const utter = new SpeechSynthesisUtterance(txt);
      window.speechSynthesis.speak(utter);
    }

    function findNearbyHotspots() {
      if (!currentLat || !currentLng) return alert("Please let us get your location first.");
      hotspotMarkers.forEach(m => map.removeLayer(m)); hotspotMarkers = [];
      const listEl = document.getElementById('hotspot-list'); listEl.innerHTML = "Searching‚Ä¶";
      const type = document.getElementById('hotspot-type').value;
      const query = `[out:json]; node["amenity"="${type}"](around:1000,${currentLat},${currentLng}); out center;`;
      fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(query)}`)
        .then(r => r.json())
        .then(data => {
          listEl.innerHTML = "<strong>Nearby Hotspots:</strong><br>";
          data.elements.forEach(el => {
            const lat = el.lat || el.center.lat, lon = el.lon || el.center.lon;
            const name = el.tags?.name || "Unnamed";
            const m = L.marker([lat, lon]).addTo(map).bindTooltip(name).bindPopup(name).on('click', () => calculateRouteTo(lat, lon));
            hotspotMarkers.push(m);
            const div = document.createElement('div'); div.className = "cursor-pointer py-1 border-b"; div.innerText = name;
            div.onclick = () => calculateRouteTo(lat, lon);
            listEl.appendChild(div);
          });
        }).catch(err => { console.error(err); listEl.innerHTML = "Error retrieving hotspots."; });
    }
  </script>
</body>
</html>