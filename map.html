<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Navigation Pro</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Leaflet Routing Machine CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
  <style>
    html, body { height:100%; margin:0; }
    #map { height:60vh; width:100%; }
    #direction-panel, #hotspot-list { overflow-y:auto; }
    .suggestions {
      position: absolute;
      background: white;
      border: 1px solid #ccc;
      border-radius: 0.25rem;
      width: 100%;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
    }
    .suggestion-item {
      padding: 0.5rem;
      cursor: pointer;
    }
    .suggestion-item:hover {
      background-color: #f3f4f6;
    }
  </style>
</head>
<body class="bg-gray-100 font-sans">

  <!-- Nav Bar -->
  <nav class="bg-gray-800 p-4">
    <div class="container mx-auto flex items-center justify-between">
      <h1 class="text-white text-xl font-bold">Navigation Pro</h1>
      <button id="prev-btn" class="p-2 bg-yellow-500 text-white rounded shadow hover:bg-yellow-600"
              onclick="routeToPrevious()">
        Previous Location
      </button>
    </div>
  </nav>

  <div class="container mx-auto px-4 py-4 relative">

    <!-- Controls -->
    <div id="controls" class="mb-4">
      <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">

        <!-- From -->
        <div class="relative">
          <input type="text" id="from"
                 class="w-full p-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                 placeholder="Starting location">
          <button class="w-full mt-2 p-2 border rounded hover:bg-gray-200"
                  onclick="startSpeechRecognition('from')">üé§</button>
        </div>

        <!-- To with autocomplete -->
        <div class="relative">
          <input type="text" id="to"
                 class="w-full p-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                 placeholder="Destination" autocomplete="off">
          <div id="to-suggestions" class="suggestions hidden"></div>
          <button class="w-full mt-2 p-2 border rounded hover:bg-gray-200"
                  onclick="startSpeechRecognition('to')">üé§</button>
        </div>

        <!-- Get Route -->
        <div>
          <button class="w-full p-2 bg-blue-600 text-white rounded shadow hover:bg-blue-700"
                  onclick="calculateRoute()">Get Route</button>
        </div>

        <!-- Hotspots -->
        <div>
          <select id="hotspot-type"
                  class="w-full p-2 border rounded shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500">
            <option value="hospital">Hospitals</option>
            <option value="restaurant">Restaurants</option>
            <option value="school">Schools</option>
            <option value="bank">Banks</option>
          </select>
          <button class="w-full mt-2 p-2 bg-gray-600 text-white rounded shadow hover:bg-gray-700"
                  onclick="findNearbyHotspots()">Find Nearby</button>
        </div>

      </div>
    </div>

    <!-- Home Button -->
    <button class="absolute top-5 left-5 p-3 bg-white rounded-full shadow hover:bg-gray-200"
            onclick="locateMe()">üè†</button>

    <!-- Map -->
    <div id="map" class="mb-4 rounded shadow"></div>

    <!-- Directions -->
    <div id="direction-panel"
         class="bg-white p-4 rounded shadow mb-4 h-32 border border-gray-200">
      Direction instructions will appear here...
    </div>

    <!-- Hotspot List -->
    <div id="hotspot-list"
         class="bg-white p-4 rounded shadow h-40 border border-gray-200">
      Nearby hotspots will appear here...
    </div>

  </div>

  <!-- Leaflet & Routing -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
  <script>
    let map, marker, routeControl, watchId;
    let currentLat, currentLng;
    let instructions = [], coordinates = [], currentInstructionIndex = 0;
    let hotspotMarkers = [], announcementInterval;
    let prevLat = null, prevLng = null;

    const osrmRouter = L.Routing.osrmv1({
      serviceUrl: 'https://router.project-osrm.org/route/v1'
    });

    document.addEventListener('DOMContentLoaded', locateMe);

    function locateMe() {
      if (!navigator.geolocation) {
        alert("Geolocation not supported‚Äîusing default view.");
        initMap(20, 77);
        return;
      }
      navigator.geolocation.getCurrentPosition(
        pos => {
          currentLat = pos.coords.latitude;
          currentLng = pos.coords.longitude;
          initMap(currentLat, currentLng);
        },
        err => {
          console.warn(err.message);
          alert("Could not get location‚Äîdefault view.");
          initMap(20, 77);
        },
        { enableHighAccuracy: true }
      );
    }

    function initMap(lat, lng) {
      map = L.map('map').setView([lat, lng], 13);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '¬© OpenStreetMap contributors'
      }).addTo(map);

      marker = L.marker([lat, lng], { draggable: true })
        .addTo(map)
        .bindPopup("You are here")
        .openPopup();

      marker.on('dragend', () => {
        const p = marker.getLatLng();
        currentLat = p.lat;
        currentLng = p.lng;
        reverseGeocode(p.lat, p.lng);
      });

      reverseGeocode(lat, lng);
      startWatchingPosition();

      document.getElementById('to')
        .addEventListener('input', handleAutocomplete);
    }

    function reverseGeocode(lat, lon) {
      fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}`)
        .then(r => r.json())
        .then(data => {
          if (data.display_name)
            document.getElementById('from').value = data.display_name;
        })
        .catch(console.error);
    }

    function startSpeechRecognition(inputId) {
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SR) return alert("Speech recognition not supported.");
      const r = new SR(); r.lang = 'en-US'; r.start();
      r.onresult = e => document.getElementById(inputId).value = e.results[0][0].transcript;
    }

    function handleAutocomplete() {
      clearTimeout(this.debounce);
      const val = this.value.trim(), box = document.getElementById('to-suggestions');
      if (!val) { box.innerHTML = ''; box.classList.add('hidden'); return; }
      this.debounce = setTimeout(async () => {
        try {
          const res = await fetch(
            `https://nominatim.openstreetmap.org/search?format=json&limit=5&q=${encodeURIComponent(val)}`
          );
          const places = await res.json();
          box.innerHTML = '';
          places.forEach(p => {
            const div = document.createElement('div');
            div.className = 'suggestion-item';
            div.innerText = p.display_name;
            div.onclick = () => {
              document.getElementById('to').value = p.display_name;
              box.innerHTML = '';
              box.classList.add('hidden');
            };
            box.appendChild(div);
          });
          box.classList.toggle('hidden', places.length === 0);
        } catch (e) { console.error(e); }
      }, 300);
    }

    function calculateRoute() {
      const dest = document.getElementById('to').value.trim();
      if (!currentLat || !currentLng) return alert("Location not ready.");
      if (!dest) return alert("Enter a destination.");
      if (routeControl) map.removeControl(routeControl);

      fetch(`https://nominatim.openstreetmap.org/search?format=json&limit=1&q=${encodeURIComponent(dest)}`)
        .then(r => r.json())
        .then(data => {
          if (!data.length) return alert("Destination not found.");
          const [lat, lon] = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
          prevLat = lat; prevLng = lon;

          routeControl = L.Routing.control({
            waypoints: [L.latLng(currentLat, currentLng), L.latLng(lat, lon)],
            router: osrmRouter,
            routeWhileDragging: true,
            show: false
          }).addTo(map);

          routeControl.on('routesfound', onRouteFound);
        }).catch(console.error);
    }

    function routeToPrevious() {
      if (prevLat === null || prevLng === null)
        return alert("No previous location found.");
      if (routeControl) map.removeControl(routeControl);
      calculateRouteTo(prevLat, prevLng);
    }

    function onRouteFound(e) {
      if (announcementInterval) clearInterval(announcementInterval);

      const route = e.routes[0];
      const sum   = route.summary;
      coordinates = route.coordinates;
      const formatter = new L.Routing.Formatter();

      // normalize instructions
      instructions = route.instructions.map(inst => {
        let txt = (inst.text || formatter.formatInstruction(inst)).toLowerCase();
        if (txt.startsWith('head ')) {
          txt = 'Go straight';
        } else if (/turn left/.test(txt)) {
          txt = 'Turn left';
        } else if (/turn right/.test(txt)) {
          txt = 'Turn right';
        } else if (/u‚Äëturn|uturn/.test(txt)) {
          txt = 'Make a U‚Äëturn';
        } else {
          txt = formatter.formatInstruction(inst);
        }
        return { text: txt, distance: inst.distance, index: inst.index };
      });

      // build direction panel
      const panel = document.getElementById('direction-panel');
      panel.innerHTML = `<div class="font-bold mb-1">
        Route: ${Math.round(sum.totalDistance)}¬†m, ETA: ${Math.round(sum.totalTime/60)}¬†min
      </div>`;
      instructions.forEach((ins, i) => {
        const d = document.createElement('div');
        d.innerText = `${i+1}. ${ins.text} (${Math.round(ins.distance)}¬†m)`;
        panel.appendChild(d);
      });

      // first announcement
      currentInstructionIndex = 0;
      if (instructions.length) {
        const first = instructions[0];
        speakText(`${first.text} in ${Math.round(first.distance)} meters`);
      }

      // periodic check
      announcementInterval = setInterval(() => {
        if (currentInstructionIndex >= instructions.length) {
          clearInterval(announcementInterval);
          return;
        }
        const next = instructions[currentInstructionIndex];
        const pt   = coordinates[next.index];
        const dist = getDistance(currentLat, currentLng, pt.lat, pt.lng);

        if (dist <= next.distance) {
          speakText(`${next.text} in ${Math.round(next.distance)} meters`);
          currentInstructionIndex++;
        }
      }, 2000);
    }

    function getDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000, r = Math.PI/180;
      const dLat = (lat2 - lat1)*r;
      const dLon = (lon2 - lon1)*r;
      const a = Math.sin(dLat/2)**2 +
                Math.cos(lat1*r)*Math.cos(lat2*r) *
                Math.sin(dLon/2)**2;
      return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    }

    function speakText(txt) {
      if (!('speechSynthesis' in window)) return;
      const u = new SpeechSynthesisUtterance(txt);
      window.speechSynthesis.speak(u);
    }

    function findNearbyHotspots() {
      if (!currentLat || !currentLng)
        return alert("Please let us get your location first.");

      hotspotMarkers.forEach(m => map.removeLayer(m));
      hotspotMarkers = [];

      const listEl = document.getElementById('hotspot-list');
      listEl.innerHTML = "Searching‚Ä¶";
      const type = document.getElementById('hotspot-type').value;
      const qry  = `[out:json]; node["amenity"="${type}"]
                      (around:1000,${currentLat},${currentLng}); out center;`;

      fetch(`https://overpass-api.de/api/interpreter?data=${encodeURIComponent(qry)}`)
        .then(r => r.json())
        .then(data => {
          listEl.innerHTML = "<strong>Nearby Hotspots:</strong><br>";
          data.elements.forEach(el => {
            const lat  = el.lat || el.center.lat;
            const lon  = el.lon || el.center.lon;
            const name = el.tags?.name || "Unnamed";
            const m    = L.marker([lat, lon])
                          .addTo(map)
                          .bindTooltip(name)
                          .bindPopup(name)
                          .on('click', () => calculateRouteTo(lat, lon));
            hotspotMarkers.push(m);

            const div = document.createElement('div');
            div.className = "cursor-pointer py-1 border-b";
            div.innerText = name;
            div.onclick = () => calculateRouteTo(lat, lon);
            listEl.appendChild(div);
          });
        })
        .catch(err => {
          console.error(err);
          listEl.innerHTML = "Error retrieving hotspots.";
        });
    }

    function calculateRouteTo(lat, lon) {
      if (routeControl) map.removeControl(routeControl);
      if (lat !== prevLat || lon !== prevLng) {
        prevLat = lat; prevLng = lon;
      }

      routeControl = L.Routing.control({
        waypoints: [L.latLng(currentLat, currentLng), L.latLng(lat, lon)],
        router: osrmRouter,
        routeWhileDragging: true,
        show: false
      }).addTo(map);

      routeControl.on('routesfound', onRouteFound);
    }
  </script>

</body>
</html>
